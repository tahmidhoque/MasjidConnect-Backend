"use client";

import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  IconButton,
  Grid,
  Tooltip,
  CircularProgress,
  Divider,
  Alert,
  InputAdornment,
  Chip,
  Container,
} from '@mui/material';
import {
  Close as CloseIcon,
  LocationOn as LocationIcon,
  Event as EventIcon,
  Description as DescriptionIcon,
} from '@mui/icons-material';
import { ContentTypeTable } from '@/components/content/table/ContentTypeTable';
import { formatDate } from '@/lib/content-helper';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import dayjs from 'dayjs';
import { useSnackbar } from '@/contexts/SnackbarContext';
import { FormTextField, FormTextArea, FormDateTimePicker, FormSwitch } from '@/components/common/FormFields';
import { useUnsavedChanges } from '@/contexts/UnsavedChangesContext';

// Custom status chip component
interface StatusChipProps {
  label: string;
  color: 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning';
}

const StatusChip: React.FC<StatusChipProps> = ({ label, color }) => {
  return (
    <Chip
      label={label}
      color={color}
      size="small"
      sx={{ minWidth: '80px' }}
    />
  );
};

interface EventItem {
  id: string;
  title: string;
  description: string;
  location: string;
  eventDate: string;
  isHighlighted: boolean;
  duration: number;
  isActive: boolean;
  startDate: string | null;
  endDate: string | null;
  createdAt: string;
  updatedAt: string;
}

export default function EventPage() {
  const [items, setItems] = useState<EventItem[]>([]);
  const [modalOpen, setModalOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<EventItem | null>(null);
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    location: '',
    eventDate: null as dayjs.Dayjs | null,
    isHighlighted: false,
    duration: 15,
    isActive: true,
    startDate: null as dayjs.Dayjs | null,
    endDate: null as dayjs.Dayjs | null,
  });
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(10);
  const [totalItems, setTotalItems] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const { showSnackbar } = useSnackbar();
  const { setHasUnsavedChanges } = useUnsavedChanges();

  // Fetch items function
  const fetchItems = useCallback(async () => {
    try {
      setLoading(true);
      const response = await fetch(`/api/content/event?page=${page}&pageSize=${pageSize}`);
      if (!response.ok) throw new Error('Failed to fetch events');
      const data = await response.json();
      setItems(data.items || data);
      
      if (data.meta) {
        setTotalItems(data.meta.total || 0);
        setTotalPages(data.meta.totalPages || 0);
      }
      setError(null);
    } catch (err) {
      console.error('Error fetching events:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch events');
    } finally {
      setLoading(false);
    }
  }, [page, pageSize]);

  useEffect(() => {
    fetchItems();
  }, [fetchItems]);

  const handleOpenModal = (item?: EventItem) => {
    if (item) {
      setEditingItem(item);
      setFormData({
        title: item.title,
        description: item.description || '',
        location: item.location || '',
        eventDate: item.eventDate ? dayjs(item.eventDate) : null,
        isHighlighted: item.isHighlighted || false,
        duration: typeof item.duration === 'string' ? parseInt(item.duration, 10) : item.duration || 15,
        isActive: item.isActive !== undefined ? item.isActive : true,
        startDate: item.startDate ? dayjs(item.startDate) : null,
        endDate: item.endDate ? dayjs(item.endDate) : null,
      });
    } else {
      setEditingItem(null);
      setFormData({
        title: '',
        description: '',
        location: '',
        eventDate: dayjs(),
        isHighlighted: false,
        duration: 15,
        isActive: true,
        startDate: null,
        endDate: null,
      });
    }
    setModalOpen(true);
  };

  const handleCloseModal = () => {
    if (hasFormChanges()) {
      if (window.confirm('You have unsaved changes. Are you sure you want to close?')) {
        closeModalAndResetState();
      }
    } else {
      closeModalAndResetState();
    }
  };

  const closeModalAndResetState = () => {
    setModalOpen(false);
    setEditingItem(null);
    setHasUnsavedChanges(false);
  };

  const hasFormChanges = () => {
    if (!editingItem) return formData.title !== '' || formData.description !== '';
    
    return (
      formData.title !== editingItem.title ||
      formData.description !== editingItem.description ||
      formData.location !== editingItem.location ||
      (formData.eventDate?.toISOString() !== dayjs(editingItem.eventDate).toISOString()) ||
      formData.isHighlighted !== editingItem.isHighlighted ||
      formData.duration !== editingItem.duration ||
      formData.isActive !== editingItem.isActive ||
      (formData.startDate?.toISOString() !== (editingItem.startDate ? dayjs(editingItem.startDate).toISOString() : null)) ||
      (formData.endDate?.toISOString() !== (editingItem.endDate ? dayjs(editingItem.endDate).toISOString() : null))
    );
  };

  const handleInputChange = (field: string) => (e: React.ChangeEvent<HTMLInputElement>) => {
    // For duration field, ensure it's stored as a number
    if (field === 'duration') {
      const value = e.target.value === '' ? 15 : parseInt(e.target.value, 10);
      setFormData({ ...formData, [field]: value });
    } else {
      setFormData({ ...formData, [field]: e.target.value });
    }
    setHasUnsavedChanges(true);
  };

  const handleSwitchChange = (field: string) => (checked: boolean) => {
    setFormData({ ...formData, [field]: checked });
    setHasUnsavedChanges(true);
  };

  const handleDateChange = (field: string) => (date: dayjs.Dayjs | null) => {
    setFormData({ ...formData, [field]: date });
    setHasUnsavedChanges(true);
  };

  const handleSubmit = async () => {
    try {
      if (!formData.title) {
        showSnackbar('Title is required', 'error');
        return;
      }

      if (!formData.eventDate) {
        showSnackbar('Event date is required', 'error');
        return;
      }

      const payload = {
        id: editingItem?.id,
        title: formData.title,
        description: formData.description,
        location: formData.location,
        eventDate: formData.eventDate ? formData.eventDate.toISOString() : null,
        isHighlighted: formData.isHighlighted,
        duration: Number(formData.duration),
        isActive: formData.isActive,
        startDate: formData.startDate ? formData.startDate.toISOString() : null,
        endDate: formData.endDate ? formData.endDate.toISOString() : null,
      };

      const url = '/api/content/event';
      const method = editingItem ? 'PUT' : 'POST';
      
      setLoading(true);
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to save event');
      }

      showSnackbar(`Event ${editingItem ? 'updated' : 'created'} successfully`, 'success');
      closeModalAndResetState();
      fetchItems();
    } catch (err) {
      console.error('Error saving event:', err);
      showSnackbar(err instanceof Error ? err.message : 'An error occurred while saving', 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!window.confirm('Are you sure you want to delete this event?')) return;

    try {
      setLoading(true);
      const response = await fetch(`/api/content/event?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to delete event');
      }

      showSnackbar('Event deleted successfully', 'success');
      fetchItems();
    } catch (err) {
      console.error('Error deleting event:', err);
      showSnackbar(err instanceof Error ? err.message : 'An error occurred while deleting', 'error');
    } finally {
      setLoading(false);
    }
  };

  // Define columns for the ContentTypeTable
  const columns = [
    {
      id: 'title',
      label: 'Title',
      render: (item: EventItem) => (
        <Tooltip title={item.title} placement="top">
          <Typography variant="body2" noWrap sx={{ fontWeight: 'medium' }}>
            {item.title}
          </Typography>
        </Tooltip>
      )
    },
    {
      id: 'description',
      label: 'Description',
      render: (item: EventItem) => (
        <Tooltip title={item.description} placement="top">
          <Typography variant="body2" noWrap sx={{ maxWidth: 250 }}>
            {item.description || 'No description provided'}
          </Typography>
        </Tooltip>
      )
    },
    {
      id: 'location',
      label: 'Location',
      render: (item: EventItem) => (
        <Tooltip title={item.location} placement="top">
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <LocationIcon fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
            <Typography variant="body2" noWrap>
              {item.location || 'No location specified'}
            </Typography>
          </Box>
        </Tooltip>
      ),
      filterable: true,
      filterOptions: [
        { value: 'all', label: 'All Locations' },
        { value: 'Online', label: 'Online' },
        { value: 'Main Hall', label: 'Main Hall' },
        { value: 'Meeting Room', label: 'Meeting Room' },
        { value: 'Prayer Hall', label: 'Prayer Hall' },
        { value: 'Community Center', label: 'Community Center' }
      ]
    },
    {
      id: 'eventDate',
      label: 'Event Date',
      render: (item: EventItem) => (
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <EventIcon fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
          <Typography variant="body2">
            {item.eventDate ? formatDate(item.eventDate) : 'N/A'}
          </Typography>
        </Box>
      )
    },
    {
      id: 'duration',
      label: 'Display Duration',
      render: (item: EventItem) => (
        <Typography variant="body2">
          {item.duration || 15} seconds
        </Typography>
      )
    },
    {
      id: 'dateRange',
      label: 'Display Period',
      render: (item: EventItem) => (
        <Tooltip 
          title={
            item.startDate && item.endDate ? 
            `From ${formatDate(item.startDate)} to ${formatDate(item.endDate)}` : 
            'No specific display period set'
          } 
          placement="top"
        >
          <Typography variant="body2" noWrap>
            {item.startDate && item.endDate ? 
              `${formatDate(item.startDate)} - ${formatDate(item.endDate)}` : 
              <Typography component="span" color="text.secondary" sx={{ fontStyle: 'italic' }}>Always visible</Typography>
            }
          </Typography>
        </Tooltip>
      )
    },
    {
      id: 'isActive',
      label: 'Status',
      render: (item: EventItem) => (
        <StatusChip 
          label={item.isActive ? 'Active' : 'Inactive'} 
          color={item.isActive ? 'success' : 'error'} 
        />
      ),
      filterable: true,
      filterOptions: [
        { value: 'all', label: 'All' },
        { value: 'Active', label: 'Active' },
        { value: 'Inactive', label: 'Inactive' }
      ]
    },
    {
      id: 'isHighlighted',
      label: 'Highlighted',
      render: (item: EventItem) => (
        <StatusChip 
          label={item.isHighlighted ? 'Yes' : 'No'} 
          color={item.isHighlighted ? 'primary' : 'default'} 
        />
      ),
      filterable: true,
      filterOptions: [
        { value: 'all', label: 'All' },
        { value: 'Yes', label: 'Yes' },
        { value: 'No', label: 'No' }
      ]
    }
  ];

  return (
    <Container maxWidth="xl">
      <Box sx={{ py: 4 }}>
        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
            {error}
          </Alert>
        )}
        
        <Box sx={{ mb: 3 }}>
          <Typography variant="h4" component="h1" gutterBottom>
            Events
          </Typography>
          <Typography variant="subtitle1" color="text.secondary">
            Create and manage events to display on your screens
          </Typography>
          <Divider sx={{ mt: 2 }} />
        </Box>

        <ContentTypeTable
          items={items}
          isLoading={loading}
          subtitle="Schedule and promote upcoming events for your community"
          emptyMessage="No events found. Click 'Add Event' to create your first event."
          searchEmptyMessage="No events match your search criteria."
          addButtonLabel="Add Event"
          onAdd={() => handleOpenModal()}
          onEdit={handleOpenModal}
          onDelete={handleDelete}
          onRefresh={fetchItems}
          getItemId={(item) => item.id}
          columns={columns}
        />
      </Box>

      <LocalizationProvider dateAdapter={AdapterDayjs}>
        <Dialog
          open={modalOpen}
          onClose={handleCloseModal}
          maxWidth="md"
          fullWidth
          PaperProps={{
            sx: {
              m: 2,
              borderRadius: '12px',
              maxWidth: { xs: 'calc(100% - 32px)', sm: '700px' }
            }
          }}
        >
          <DialogTitle sx={{ fontSize: '1.25rem', fontWeight: 'medium', pb: 1, px: '32px', pt: '24px' }}>
            {editingItem ? 'Edit Event' : 'New Event'}
            <IconButton
              aria-label="close"
              onClick={handleCloseModal}
              sx={{
                position: 'absolute',
                right: 8,
                top: 8,
                color: 'text.secondary',
              }}
            >
              <CloseIcon />
            </IconButton>
          </DialogTitle>
          <DialogContent sx={{ pt: 2, pb: 2, px: '32px', paddingTop: '20px !important' }}>
            {error && (
              <Box sx={{ mb: 3 }}>
                <Alert severity="error" onClose={() => setError(null)}>
                  {error}
                </Alert>
              </Box>
            )}
            
            <Grid container spacing={3}>
              <Grid item xs={12}>
                <FormTextField
                  id="title"
                  label="Event Title"
                  value={formData.title}
                  onChange={handleInputChange('title')}
                  required
                  fullWidth
                  helperText="Enter a clear, concise title for your event"
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EventIcon color="action" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>
              
              <Grid item xs={12}>
                <FormTextArea
                  id="description"
                  label="Description"
                  value={formData.description}
                  onChange={handleInputChange('description')}
                  fullWidth
                  minRows={3}
                  maxRows={6}
                  helperText="Provide details about the event including purpose, speakers, and what attendees can expect"
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <DescriptionIcon color="action" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormTextField
                  id="location"
                  label="Location"
                  value={formData.location}
                  onChange={handleInputChange('location')}
                  fullWidth
                  helperText="Specify where the event will take place (room, building, address, etc.)"
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LocationIcon color="action" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormDateTimePicker
                  label="Event Date & Time"
                  value={formData.eventDate}
                  onChange={handleDateChange('eventDate')}
                  required
                  fullWidth
                  helperText="When will the event take place"
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormTextField
                  id="duration"
                  label="Display Duration (seconds)"
                  type="number"
                  value={formData.duration}
                  onChange={handleInputChange('duration')}
                  fullWidth
                  helperText="How long this event should display on screens (in seconds)"
                  inputProps={{ 
                    min: 5, 
                    max: 60,
                    step: 1
                  }}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormSwitch
                  id="isHighlighted"
                  label="Highlight Event"
                  checked={formData.isHighlighted}
                  onChange={handleSwitchChange('isHighlighted')}
                  helperText="Give this event special visual emphasis on displays"
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormDateTimePicker
                  label="Start Showing From"
                  value={formData.startDate}
                  onChange={handleDateChange('startDate')}
                  fullWidth
                  helperText="Optional: When to start displaying this event (leave blank for immediate)"
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormDateTimePicker
                  label="Stop Showing After"
                  value={formData.endDate}
                  onChange={handleDateChange('endDate')}
                  fullWidth
                  helperText="Optional: When to stop displaying this event (leave blank to show indefinitely)"
                />
              </Grid>
              
              <Grid item xs={12}>
                <FormSwitch
                  id="isActive"
                  label="Active Status"
                  checked={formData.isActive}
                  onChange={handleSwitchChange('isActive')}
                  helperText="Toggle whether this event is currently displayed on screens"
                />
              </Grid>
            </Grid>
          </DialogContent>
          <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
            <Button onClick={handleCloseModal} color="inherit">
              Cancel
            </Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained" 
              color="primary"
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} /> : (editingItem ? 'Update' : 'Create')}
            </Button>
          </DialogActions>
        </Dialog>
      </LocalizationProvider>
    </Container>
  );
} 